# Roadmap for Developing the `ft_get_next_line.c` Function

This roadmap outlines the steps involved in developing the `ft_get_next_line.c` function, as described in the provided project document.

### 1. Requirements
#### Mandatory Part

* The primary goal is to write a function named `get_next_line` that reads a line from a file descriptor. [cite: 24]
* The function should handle multiple calls, reading the file line by line until the end. [cite: 24]
* The function should return the read line, including the newline character (`\n`), or `NULL` if there is nothing more to read or an error occurs. [cite: 25, 26]
* The function should be able to read from both files and standard input. [cite: 27]
* A `BUFFER_SIZE` macro will define the buffer size for reading, and the function should adapt to different buffer sizes. [cite: 32, 33]
* Static variables are expected to manage data persistence between function calls. [cite: 4]
* Create the `get_next_line.c` and `get_next_line_utils.c` source files, along with the `get_next_line.h` header file. [cite: 24]
* Ensure compliance with the norm and handle memory allocation/deallocation properly. [cite: 6, 10]
#### Bonus Part
- Optimize the function to use only one static variable. [cite: 46]
- Extend the function to manage multiple file descriptors concurrently. [cite: 47]
- Create the bonus part files with the `_bonus.c` and `_bonus.h` suffixes. [cite: 50]  
#### Code

- Prototype:
`char *get_next_line(int fd);`

- Inputs:
	- fd: The file descriptor to read from
- Return:
	- Data Array:
		- Read line: correct behavior
		- NULL: there is nothing else to read, or an error occurred
- Brief:
	- A function that returns a line read from a file descriptor
- Files Structure
	- /main
		- ../get_next_line.c
		- ../get_next_line_utils.c
		- ../get_next_line.h
	
- Undefined behavior to be avoided and protected against:
	- If the file pointed to by the file descriptor changed since the last call whereas read() didnâ€™t reach the end of file.
	- has an undefined behavior when reading a binary file. However, you can implement a logical way to handle this behavior if you want to.

- Forbidden Functions:
	- You are not allowed to use your libft in this project.
	- lseek() is forbidden.
	- Global variables are forbidden.
  
### 2. Designing the Solution
* **Core Logic:** Implement a loop that reads a chunk of data from the file descriptor using the `read` system call. Search for a newline character within the buffer. [cite: 32, 33, 39]

* **Buffer Management:** Utilize a static variable to store the buffer and manage leftover data between calls. [cite: 4]

* **Line Assembly:** Concatenate the chunks of data read into a complete line. [cite: 40]

* **Error Handling:** Incorporate checks for errors during file reading. [cite: 26]

* **End-of-File:** Detect the end of the file and return `NULL` accordingly. [cite: 26]
### 3. Coding Designing and File Structure
#### Mandatory Part

- Use Makefile with
- Flags cc -Wall -Wextra -Werror -D BUFFER_SIZE=INPUT_VALUE
- Rules $(NAME), all, clean, fclean and re. Extra rule for bonus to include extra libraries.
- Functions and Libraries that will be needed and will be placed inside `get_next_line_utils.c`:
	- Function 1  
- File Strucure Expanded:
	 - ....
#### Bonus Part
- Functions and Libraries that will be needed and will be placed inside `get_next_line_utils.c`:  
	- Function 1 ...
	- Func2...
	- ...
- File Strucure Expanded:
	- ....
	- ...
### 4. Unit Tester

* Write test cases to verify the function's behavior with different files, buffer sizes, and input scenarios. [cite: 17]

- Input Scenarios:
	- ...
	- ...

- Inputs to be tested:
	- ...
	- ...

- Outputs Expected:
	- ...
	- ...

- Files:
	- ...
	- ...

- Buffers sizes:
	- from 1 to 10,000,000

  

### 5. Submission

  

* Submit the completed code to the assigned Git repository. [cite: 20]

* Double-check file names for correctness. [cite: 57]