# Roadmap for Developing the `ft_get_next_line.c` Function

This roadmap outlines the steps involved in developing the `ft_get_next_line.c` function, as described in the provided project document.

### 1. Requirements
#### Mandatory Part

* The primary goal is to write a function named `get_next_line` that reads a line from a file descriptor. [cite: 24]
* The function should handle multiple calls, reading the file line by line until the end. [cite: 24]
* The function should return the read line, including the newline character (`\n`), or `NULL` if there is nothing more to read or an error occurs. [cite: 25, 26]
* The function should be able to read from both files and standard input. [cite: 27]
* A `BUFFER_SIZE` macro will define the buffer size for reading, and the function should adapt to different buffer sizes. [cite: 32, 33]
* Static variables are expected to manage data persistence between function calls. [cite: 4]
* Create the `get_next_line.c` and `get_next_line_utils.c` source files, along with the `get_next_line.h` header file. [cite: 24]
* Ensure compliance with the norm and handle memory allocation/deallocation properly. [cite: 6, 10]
#### Bonus Part
- Optimize the function to use only one static variable. [cite: 46]
- Extend the function to manage multiple file descriptors concurrently. [cite: 47]
- Create the bonus part files with the `_bonus.c` and `_bonus.h` suffixes. [cite: 50]  
#### Code

- Prototype:
`char *get_next_line(int fd);`

- Inputs:
	- fd: The file descriptor to read from
- Return:
	- Data Array:
		- Read line: correct behavior
		- NULL: there is nothing else to read, or an error occurred
- Brief:
	- A function that returns a line read from a file descriptor
- Files Structure
	- /main
		- ../get_next_line.c
		- ../get_next_line_utils.c
		- ../get_next_line.h
	
- Undefined behavior to be avoided and protected against:
	- If the file pointed to by the file descriptor changed since the last call whereas read() didn’t reach the end of file.
	- has an undefined behavior when reading a binary file. However, you can implement a logical way to handle this behavior if you want to.

- Forbidden Functions:
	- You are not allowed to use your libft in this project.
	- lseek() is forbidden.
	- Global variables are forbidden.
  
### 2. Designing the Solution
* **Core Logic:** Implement a loop that reads a chunk of data from the file descriptor using the `read` system call. Search for a newline character within the buffer. [cite: 32, 33, 39]
* **Buffer Management:** Utilize a static variable to store the buffer and manage leftover data between calls. [cite: 4]
* **Line Assembly:** Concatenate the chunks of data read into a complete line. [cite: 40]
* **Error Handling:** Incorporate checks for errors during file reading. [cite: 26]
* **End-of-File:** Detect the end of the file and return `NULL` accordingly. [cite: 26]

#### FlowChart High Level

``` mermaid
graph TD
    A["get_next_line(int fd)"] --> B["Manage buffer"]
    B --> C["Read data"]
    C --> D{End of file?}
    D -- Yes --> E["Return NULL"]
    D -- No --> F{Newline found?}
    F -- Yes --> G["Extract and return line"]
    G --> A
    F -- No --> C
```
### Flow Chart Low Level
``` mermaid
graph TD
    A["get_next_line(int fd)"] --> B["Static buffer initialized?"]
    B -- Yes --> C["read_and_buffer(fd, buffer, bytes_read)"]
    C --> J["read() system call"]
    J --> K{Bytes read > 0?}
    K -- Yes --> L["Store data in buffer"]
    L --> M["Check for errors"]
    M --> C
    K -- No --> E
    B -- No --> D["Initialize static buffer"]
    D --> C
    E{End of file reached?}
    E -- Yes --> F["Return NULL"]
    E -- No --> G{Newline found in buffer?}
    G -- Yes --> H["extract_line(buffer)"]
    H --> N["find_newline(buffer)"]
    N --> O["malloc(size_t size)"]
    O --> P["Copy line from buffer  (using ft_strjoin, ft_strdup, etc.)"]
    P --> Q["update_buffer(buffer)"] 
    Q --> I
    G -- No --> C
    I["Return extracted line"]
```

### 3. Coding Designing and File Structure
#### Mandatory Part

- Use Makefile with
	- Flags cc -Wall -Wextra -Werror -D BUFFER_SIZE=INPUT_VALUE
	- Rules $(NAME), all, clean, fclean and re. Extra rule for bonus to include extra libraries.
- Functions and Libraries that will be needed and will be placed inside `get_next_line_utils.c`:
	- `read`: Reads data from the file descriptor.  
	- `malloc`: Dynamically allocates memory for the line buffer.  
	- `free`: Releases allocated memory.  
	- Helper functions for string manipulation (e.g., `ft_strchr`, `ft_strjoin`, `ft_strdup`, `ft_substr`, etc.).
	  
- File Strucure Expanded:
	- /main
	    - .../get_next_line.c
	    - .../get_next_line_utils.c
	    - .../get_next_line.h
	    - .../main.c
#### Bonus Part
- Functions and Libraries that will be needed and will be placed inside `get_next_line_utils.c`:
    - A data structure (e.g., linked list) to store buffers and associated data for each file descriptor.
    - Functions to manage the data structure (e.g., add a node, find a node, delete a node).
    - Adaptations of the helper functions from the mandatory part to work with the chosen data structure.
- File Strucure Expanded:
    - /main_bonus
        - .../get_next_line_bonus.c
        - .../get_next_line_utils_bonus.c
        - .../get_next_line_bonus.h
        - .../main.c
### 4. Unit Tester

* Write test cases to verify the function's behavior with different files, buffer sizes, and input scenarios. [cite: 17]

- Input Scenarios:
    - Empty file.
    - Corrupted file.
    - File with a single line.
    - File with multiple lines of varying lengths.
    - Lines with the maximum length that can be stored in the buffer.
    - Lines that are longer than the buffer size.
    - Reading from standard input.
- Inputs to be tested:
    - Text files with different content.
    - Standard input (simulated or using keyboard input).
- Outputs Expected:
    - Correctly read lines, including newline characters.
    - `NULL` when reaching the end of the file.
    - Proper handling of different buffer sizes.
    - No memory leaks.
- Files:
    - Files with a variety of characters, including special characters and Unicode characters.
    - Files with different line endings (e.g., `\n`, `\r\n`).
    - Corrupted file.
- Buffers sizes:
    - from 1 to 10,000,000

### 5. Submission
* Submit the completed code to the assigned Git repository. [cite: 20]
* Double-check file names for correctness. [cite: 57]